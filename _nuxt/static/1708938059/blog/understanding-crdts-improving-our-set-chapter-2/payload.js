__NUXT_JSONP__("/blog/understanding-crdts-improving-our-set-chapter-2", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT,bU,bV,bW,bX,bY,bZ,b_,b$,ca,cb){return {data:[{article:{slug:"2024-02-25-understanding-crdts-improving-our-set-chapter-2",description:"In the previous article, we implemented a basic Set with support for additions and removals, as well as basic CRDT semantics. Despite working in simple cases, we also highlighted two significant limitations:",layout:"post",title:"Understanding CRDTs: Improving our Set (Chapter 2)",author:"Federico Terzi",date:"2024-02-25T00:00:00.000Z",categories:"distributed systems crdt set eventual convergence real time collaboration",social_title:aN,social_subtitle:"Improving our Set (Chapter 2)",header:bc,adaptive_images:true,toc:[{id:bd,depth:aq,text:be},{id:bf,depth:aq,text:bg},{id:bh,depth:aq,text:bi},{id:bj,depth:aq,text:bk},{id:bl,depth:aq,text:bm},{id:bn,depth:aq,text:bo}],body:{type:aO,children:[{type:b,tag:j,props:{},children:[{type:a,value:bp},{type:b,tag:aC,props:{to:aP},children:[{type:a,value:bq}]},{type:a,value:br}]},{type:a,value:f},{type:a,value:f},{type:b,tag:aQ,props:{},children:[{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"An element cannot be re-added to the Set after being removed"}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"Although a removal would "},{type:b,tag:M,props:{},children:[{type:a,value:"logically"}]},{type:a,value:" remove an element from the Set, the underlying data structure’s size keeps increasing over time. If we perform many deletions, this could bloat the size of the structure significantly."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In this article, we’ll try to tackle the first problem, discussing different approaches and tradeoffs."}]},{type:a,value:f},{type:b,tag:bs,props:{id:"supporting-additions-after-removals"},children:[{type:b,tag:u,props:{href:"#supporting-additions-after-removals",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:"Supporting additions after removals"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As we mentioned, our current Set implementation does not allow an element to be restored after being deleted:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:bt},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:ar}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:aD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bu},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:bv}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:bw},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:ar}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:aD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bx},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bx},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:au}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:aF}]},{type:a,value:"\n\nreplicaA"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:aF}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Add 'a' back"}]},{type:a,value:bu},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F false! Ouch, it should be true"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"For some use cases, this is a significant limitation: imaging building a grocery list application. You might add some elements to your “to buy” set, and later remove them after the purchase. This would work for a while, but then you might find yourself needing to buy the same product again. In this case, you would need to add elements to the set again after deleting them."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The reason why we are unable to add an element back after its removal is that our current implementation always prioritizes the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" set. Let’s take the following scenario as an example:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:u},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In this case, our Set will logically contain only element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:", as element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" is present in the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" set and thus ignored."}]},{type:a,value:f},{type:b,tag:as,props:{id:bd},children:[{type:b,tag:u,props:{href:"#attempt-0-removing-elements",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:be}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"If having "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" in the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" Set prevents us from restoring it, can’t we simply remove "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" from "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" after re-adding it? For example:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:u},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Then user calls set.add(\"b\")"}]},{type:a,value:"\n\nelements "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:u},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Unfortunately, as we’ve seen in the previous chapter, removing elements from our sets becomes problematic once replicas and synchronization enter the picture. In those cases, deleting "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" from the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" set could cause it to randomly disappear again during synchronization, so we need a better solution."}]},{type:a,value:f},{type:b,tag:as,props:{id:bf},children:[{type:b,tag:u,props:{href:"#attempt-1-adding-timestamps",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:bg}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Let’s take a step back and focus on our expected outcome: our goal is to be able to add an element to the Set "},{type:b,tag:M,props:{},children:[{type:a,value:av}]},{type:a,value:" removing it. If we had a way to determine whether our element was added before or after its removal, we could decide whether to ignore it or not. For example, if element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:by},{type:b,tag:M,props:{},children:[{type:a,value:av}]},{type:a,value:bz},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:", then element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" should be included, but if element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:by},{type:b,tag:M,props:{},children:[{type:a,value:"before"}]},{type:a,value:bz},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:", then it should be ignored. In other words, we need some kind of "},{type:b,tag:M,props:{},children:[{type:a,value:bA}]},{type:a,value:" between our Set operations."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An initial approach to achieve ordering is to attach a timestamp to our additions and removals. We are going to do this by converting our "},{type:b,tag:i,props:{},children:[{type:a,value:ab}]},{type:a,value:bB},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" Sets into "},{type:b,tag:M,props:{},children:[{type:a,value:"Maps:"}]}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Before"}]},{type:a,value:bC},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:u},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F After"}]},{type:a,value:bC},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In this case, the keys of our map represent the elements, while the values represent the time in which the elements were added or removed."}]},{type:a,value:f},{type:b,tag:aw,props:{},children:[{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Note: in the previous example, timestamps are represented as string dates to make them easier to read and understand by humans. This implementation would be quite inefficient in practice, so we are going to use Unix timestamps in the actual code."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The time information will be provided by the "},{type:b,tag:i,props:{},children:[{type:a,value:ag}]},{type:a,value:bB},{type:b,tag:i,props:{},children:[{type:a,value:au}]},{type:a,value:" methods:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:ax},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,aH]},children:[{type:a,value:b}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:ar}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:bD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:bE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:au}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,aH]},children:[{type:a,value:b}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:ar}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:bD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:bE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"With the time information, we can finally refine our Set logic to support additions after removals:"}]},{type:a,value:f},{type:b,tag:aw,props:{},children:[{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An element is present in our Set if:"}]},{type:a,value:f},{type:b,tag:aQ,props:{},children:[{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"It’s present in the "},{type:b,tag:i,props:{},children:[{type:a,value:ab}]},{type:a,value:" and not in the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"OR if the timestamp in the "},{type:b,tag:i,props:{},children:[{type:a,value:ab}]},{type:a,value:" is greater or equal than the timestamp in the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Thanks to the second condition, we are now able to add an element back after its removal. This works because whenever we "},{type:b,tag:i,props:{},children:[{type:a,value:ag}]},{type:a,value:" an element, we also update its timestamp, and if this timestamp is greater than the current "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:" timestamp, we consider the element to be present."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"A possible implementation for the "},{type:b,tag:i,props:{},children:[{type:a,value:$}]},{type:a,value:" method could be:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:ax},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,aH]},children:[{type:a,value:b}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:" additionTime "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aJ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"additionTime "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aS}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y,aT]},children:[{type:a,value:aU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Element was never added"}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aV}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bF]},children:[{type:a,value:"false"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:bG},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aJ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:"removalTime"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Was the element removed before or after its addition?"}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aV}]},{type:a,value:bG},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:"\u003C="}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F The element was never removed"}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aV}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bF]},children:[{type:a,value:aa}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Finally, to make our Set a proper CRDT, we’ll need to update the "},{type:b,tag:i,props:{},children:[{type:a,value:al}]},{type:a,value:" method as well:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:ax},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,aH]},children:[{type:a,value:"otherSet"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:bH}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:bI}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bJ}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:bL}]},{type:a,value:bM},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:" existingAdditionTime "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aJ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Update the local addition time only if the remote addition time is greater"}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bN},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aS}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y,aT]},children:[{type:a,value:aU}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bO}]},{type:a,value:bN},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bP}]},{type:a,value:" additionTime\n      "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:bQ},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:aX},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aW},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:bH}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:bI}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bJ}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:bR},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:bL}]},{type:a,value:bM},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:" existingRemovalTime "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aJ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Update the local removal time only if the remote removal time is greater"}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aK}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:bS},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aS}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y,aT]},children:[{type:a,value:aU}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bO}]},{type:a,value:bS},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:bP}]},{type:a,value:" removalTime\n      "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:bQ},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:O}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:b},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:bR},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:X},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"We are now ready to test our Set again (the full code is available "},{type:b,tag:u,props:{href:"https:\u002F\u002Fgithub.com\u002Ffederico-terzi\u002Fcrdt-experiments\u002Fblob\u002Fmain\u002Fcrdt-article-examples\u002Fpart-2\u002Fset-with-timestamps.js",rel:[am,an,ao],target:ap},children:[{type:b,tag:az,props:{},children:[{type:a,value:aY}]}]},{type:a,value:"):"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:ax},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:bt},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:ar}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:aD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:"\n  replicaA"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:bv}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Wait for some time between operation."}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F This way, the new Date.getTime() call can't return the same value"}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aZ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:a$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:af}]},{type:a,value:bw},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:ar}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,T]},children:[{type:a,value:aD}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bT},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bT},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:au}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:aF}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aZ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:a$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:aF}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,y,W]},children:[{type:a,value:aZ}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:a_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:a$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:bU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,N,T]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:t}]},{type:b,tag:c,props:{className:[d,B,x,v]},children:[{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F true! Yay, 'a' is back!"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Yay, our Set can now handle additions after removals! Is this ready for production? Well, not exactly. Our current implementation suffers from a subtle, but very problematic edge case, which we’ll discuss in the next section."}]},{type:a,value:f},{type:b,tag:as,props:{id:bh},children:[{type:b,tag:u,props:{href:"#physical-time-and-distributed-systems",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:bi}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In the implementation we just discussed, timestamps play an important role: they allow us to tell which operation comes first. In other words, we are relying on timestamps to determine the "},{type:b,tag:M,props:{},children:[{type:a,value:"ordering of operations"}]},{type:a,value:", which in turn determines which elements are present in the set and which are not. Unfortunately, this approach can break down in subtle ways when dealing with distributed systems."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Most of our devices, including laptops and mobile phones, rely on a hardware device to keep track of time: the clock. These clocks are usually based on quartz oscillators and are not very precise, so every device has its own notion of time. For example, this is a picture of my car’s clock:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:bV,props:{alt:bW,src:"\u002Fposts\u002F2024-02-25-understanding-crdts-improving-our-set\u002Fimage0.png"},children:[]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Every few weeks, I might need to adjust the time, as it might have drifted by one or two minutes. Some of you might be wondering: why isn’t this time drift happening on our phones and laptops? Well… it is! The reason we don’t notice is a protocol known as "},{type:b,tag:u,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FNetwork_Time_Protocol",rel:[am,an,ao],target:ap},children:[{type:a,value:"NTP "}]},{type:a,value:p},{type:b,tag:M,props:{},children:[{type:a,value:"Network Time Protocol)"}]},{type:a,value:", which allows internet-connected devices to periodically sync their time with NTP servers, down to a \u003C100ms precision. Unfortunately, my car is quite old and doesn’t have any kind of internet connectivity, so NTP is not an option there. Until I keep my car, I’ll need to keep the time up to date manually (though as you can see from the year, I’m not particularly good at it :D )."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As long as the NTP protocol works, our devices will have a reasonably precise clock, so why shouldn’t we rely on timestamps for the operation ordering?"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In software systems, data integrity is usually one of the top concerns. For example, let’s take two hypothetical bugs:"}]},{type:a,value:f},{type:b,tag:ba,props:{},children:[{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"A bug causing application instances to crash"}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"A bug silently corrupting data in our database"}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Which one sounds scarier?"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As a result, when designing a data structure like our CRDT Set, we should always think about the worst-case scenarios: what happens if the time in our local machine goes off? Let’s see an example, starting from this Set state:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Let’s say for some reason, our local time is completely off and we decide to remove element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:". As we discussed before, this causes a new entry to be added to the "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:bX}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:bY}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:ax},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F \u003C- year is set to 2099"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"From the user perspective, this works correctly: the element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" is removed (because 2099 \u003E 2024)."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"After a while, the CRDT Set is replicated to another replica, which might decide to add element "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" again. As a result, we update the timestamp of entry "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:"  in the "},{type:b,tag:i,props:{},children:[{type:a,value:ab}]},{type:a,value:bX}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:at}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F \u003C- updated, but still less than 2099!"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,L]},children:[{type:a,value:bY}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"But this time, the "},{type:b,tag:i,props:{},children:[{type:a,value:K}]},{type:a,value:" element does not come back… In fact, it will not come back for the next 75 years! By relying on physical timestamps to determine the order of operations, we might cause silent data loss or corruption in the case of out-of-time clocks. We can do better than that."}]},{type:a,value:f},{type:b,tag:aw,props:{},children:[{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Aside: How likely is this out-of-time scenario to happen?"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Despite being a rare occurrence, these are some scenarios in which a device’s time could experience some edge-case behaviors:"}]},{type:a,value:f},{type:b,tag:ba,props:{},children:[{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"Firewalls could be misconfigured and temporarily block NTP synchronization, making the local clock slowly drift over time."}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"When the drift between the local clock and the NTP server clock is too large, the NTP protocol might decide to reset the local clock. From the perspective of local applications, the clock would have jumped forward or backward in time."}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"Users could even misconfigure their local time on purpose, for example, trying to elude “trial periods” of certain proprietary software."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"If you want to know more about this topic, I highly recommend reading the “Unreliable Clocks” chapter from "},{type:b,tag:u,props:{href:"https:\u002F\u002Fwww.oreilly.com\u002Flibrary\u002Fview\u002Fdesigning-data-intensive-applications\u002F9781491903063\u002F",rel:[am,an,ao],target:ap},children:[{type:a,value:"Designing Data-Intensive Applications"}]},{type:a,value:" by Martin Kleppmann, one of the best software engineering books ever written."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"So if physical timestamps are not a good option for this use case, what should we use? A better mechanism to determine the order of operations in distributed systems is "},{type:b,tag:u,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FVersion_vector",rel:[am,an,ao],target:ap},children:[{type:b,tag:M,props:{},children:[{type:a,value:"Version Vectors"}]}]},{type:b,tag:M,props:{},children:[{type:a,value:w}]},{type:a,value:" which we are going to cover in the next section."}]},{type:a,value:f},{type:b,tag:as,props:{id:bj},children:[{type:b,tag:u,props:{href:"#attempt-2-version-vectors",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:bk}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Version Vectors are a mechanism for tracking changes to data in a distributed system. Most importantly, they can do so without relying on physical time."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"To introduce Version Vectors, let’s imagine a distributed scenario in which two replicas exist. We’ll call them Alice and Bob:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:b,tag:bV,props:{alt:bW,src:"\u002Fposts\u002F2024-02-25-understanding-crdts-improving-our-set\u002Fimage1.png"},children:[]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When using Version Vectors, each replica has to have a "},{type:b,tag:az,props:{},children:[{type:a,value:bZ}]},{type:a,value:" ID, which we’ll call "},{type:b,tag:M,props:{},children:[{type:a,value:"replica ID"}]},{type:a,value:". For simplicity, Alice will have "},{type:b,tag:i,props:{},children:[{type:a,value:"ID = alice"}]},{type:a,value:" and Bob will have "},{type:b,tag:i,props:{},children:[{type:a,value:"ID = bob"}]},{type:a,value:t}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Version Vectors can be thought of as "},{type:b,tag:M,props:{},children:[{type:a,value:"maps"}]},{type:a,value:", in which the keys are the replica IDs and the values are the number of changes to the data by the given replica. For example, when Alice adds a new element, the corresponding Version Vector will be:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"which can be read as “Alice has made one edit to the data so far”. If Alice performs another update, the Version Vector will become:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"And if this value is then modified by Bob, the Version Vector will become:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"which can be read as “Alice has made 2 edits to the data, while Bob made one edit”."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When executing an operation (either "},{type:b,tag:i,props:{},children:[{type:a,value:ag}]},{type:a,value:" or "},{type:b,tag:i,props:{},children:[{type:a,value:au}]},{type:a,value:" ), our CRDT Set will attach a Version Vector to the value, in the same way as we did with the timestamps:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"All good so far, but we still haven’t discussed how Version Vectors can help us. To answer that question, let’s take a step back: our goal is to determine whether a removal occurred "},{type:b,tag:M,props:{},children:[{type:a,value:"before or after"}]},{type:a,value:" the corresponding addition, as that will determine whether the element is present in the set or not. In other words, we need a way to determine an "},{type:b,tag:M,props:{},children:[{type:a,value:bA}]},{type:a,value:" between the additions and removals of the same element. Version Vectors serve exactly that purpose, let’s see how:"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Every time a replica executes an operation on a given element, it increments the corresponding counter in the Version Vector:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F After an operation by Alice"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Because we know that replica IDs are unique (more on this below), we can derive a partial ordering by comparing two version vectors. For example, given these two Version Vectors:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"we know that "},{type:b,tag:i,props:{},children:[{type:a,value:aA}]},{type:a,value:g},{type:b,tag:az,props:{},children:[{type:a,value:"must"}]},{type:a,value:" have come "},{type:b,tag:M,props:{},children:[{type:a,value:av}]},{type:a,value:g},{type:b,tag:i,props:{},children:[{type:a,value:aL}]},{type:a,value:" (because the replica IDs are unique and each operation causes an increment in the current replica counter). For example, let’s consider the following scenario:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"In this case, because "},{type:b,tag:i,props:{},children:[{type:a,value:aA}]},{type:a,value:b_},{type:b,tag:M,props:{},children:[{type:a,value:av}]},{type:a,value:g},{type:b,tag:i,props:{},children:[{type:a,value:aL}]},{type:a,value:", we know that element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" was removed. On the other hand, the following scenario displays a Set in which the element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" is present:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F \u003C- 3 is greater than 2, so 'a' is present"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When multiple replicas modify the same data, each replica increments its own counter. For example:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F After Bob modifies the data"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"By comparing these two version vectors, we know that "},{type:b,tag:i,props:{},children:[{type:a,value:bb}]},{type:a,value:b_},{type:b,tag:M,props:{},children:[{type:a,value:av}]},{type:a,value:g},{type:b,tag:i,props:{},children:[{type:a,value:aL}]},{type:a,value:", because the former is a superset of the latter. In other words, a version vector A is greater than a version vector B if all counters of A are greater or equal to the corresponding counters on B."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"So in the following scenario, we know that "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" is not present in the Set:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F \u003C- This VV is greater than {alice: 1}"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The trickiest scenario happens when two replicas modify the same data concurrently:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F Alice modifies the value"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F At the same time, Bob modifies the value"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Does "},{type:b,tag:i,props:{},children:[{type:a,value:aA}]},{type:a,value:"  come before or after "},{type:b,tag:i,props:{},children:[{type:a,value:bb}]},{type:a,value:"? Neither of the two! The two version vectors are "},{type:b,tag:M,props:{},children:[{type:a,value:"concurrent"}]},{type:a,value:". In other words, we can’t tell which update came first by just looking at their version vectors. What should we do in this case? Let’s discuss an example to illustrate a possible approach."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Let’s assume both Alice and Bob start from the following state:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"From the rules we discussed before, we know that this Set contains element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" ."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Then, each replica updates its set concurrently. In particular, Alice removes and then adds "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" again:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"While Bob only removes "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:", without adding it back:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When the two replicas synchronize, a conflict occurs: should "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" be present or not? Should the actions of Alice take precedence over the ones from Bob, or vice versa? It depends on the application, as different use cases require different approaches."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"A safe approach we could use is "},{type:b,tag:M,props:{},children:[{type:a,value:"prioritizing additions over removals when a conflict occurs"}]},{type:a,value:", a policy known as "},{type:b,tag:M,props:{},children:[{type:a,value:"Add Wins"}]},{type:a,value:". According to this logic, if some replica deletes an element while another replica adds it, then the addition should “win”. This policy is the safest as it minimizes the risk of unwanted data loss. For example, it would be easy for Bob to remove element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" again if he’s really convinced about his choice, with minimal UX impact. But if we didn’t adopt the Add-Win policy, Alice might have element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" silently disappear after the synchronization, which could lead to a bad UX."}]},{type:a,value:f},{type:b,tag:aw,props:{},children:[{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Note: Different approaches to conflict resolution are possible, the most suitable of which depends on the specific use case. For example, some applications might require to “merge” elements when a conflict occurs, rather than having one override the other. Others might prefer the removal operation to take precedence."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"If we opt for the Add-Wins policy in our CRDT Set, Alice’s addition will win over Bob’s removal. The only thing left to figure out is what the Version Vector will be."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"When a conflict occurs, we are going to "},{type:b,tag:M,props:{},children:[{type:a,value:al}]},{type:a,value:" the two Version Vectors. A merge consists of creating a Version Vector whose counters are the maximum value across all conflicting vectors’ counters. For example, merging "},{type:b,tag:i,props:{},children:[{type:a,value:aA}]},{type:a,value:" with "},{type:b,tag:i,props:{},children:[{type:a,value:bb}]},{type:a,value:" will result in "},{type:b,tag:i,props:{},children:[{type:a,value:"{alice: 2, bob: 1}"}]},{type:a,value:". By applying this logic to our previous example, we’ll end up with the following state:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:a,value:V},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F \u003C- merged vector"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:a,value:z},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,J]},children:[{type:a,value:"\u002F\u002F The value of the removals version vector doesn't really matter, as long as it's smaller than the addition version vector"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The resulting set will contain element "},{type:b,tag:i,props:{},children:[{type:a,value:u}]},{type:a,value:" , because the resulting vector ("},{type:b,tag:i,props:{},children:[{type:a,value:"{alice: 3, bob: 1}"}]},{type:a,value:" ) is greater than the vector in "},{type:b,tag:i,props:{},children:[{type:a,value:O}]},{type:a,value:t}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An important side-effect of the merge, which might not be obvious at first, is that the resulting version vector now “encodes” the fact that it came after "},{type:b,tag:az,props:{},children:[{type:a,value:"both"}]},{type:a,value:" concurrent updates. In other words, we can tell for sure that this addition comes after both Alice’s addition and Bob’s removal. This allows us to accurately track the way our data evolves when multiple replicas update it."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"We now have all the necessary ingredients to implement our Version Vector CRDT Set in JS. Because the implementation is quite long, I’ve decided to not include it in the article, but you can find it on the GitHub repo "},{type:b,tag:u,props:{href:"https:\u002F\u002Fgithub.com\u002Ffederico-terzi\u002Fcrdt-experiments\u002Fblob\u002Fmain\u002Fcrdt-article-examples\u002Fpart-2\u002Fset-with-version-vector.js",rel:[am,an,ao],target:ap},children:[{type:a,value:aY}]},{type:a,value:t}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"All right! We now have implemented a CRDT Set that supports additions, removals, and concurrent updates without relying on physical clocks, making it more robust for use in distributed systems."}]},{type:a,value:f},{type:b,tag:as,props:{id:bl},children:[{type:b,tag:u,props:{href:"#remarks-on-replica-ids",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:bm}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"An important discussion we should have is related to Replica IDs. Version Vectors (as well as other approaches we’ll discuss in the upcoming chapters) rely on the fact that every replica has a "},{type:b,tag:az,props:{},children:[{type:a,value:bZ}]},{type:a,value:" ID. Without the uniqueness guarantee, we couldn’t infer an ordering between two Version Vectors. For example, if two replicas had "},{type:b,tag:i,props:{},children:[{type:a,value:"Alice"}]},{type:a,value:" as replica ID, we couldn’t tell for sure if the version vector "},{type:b,tag:i,props:{},children:[{type:a,value:aA}]},{type:a,value:" comes after "},{type:b,tag:i,props:{},children:[{type:a,value:aL}]},{type:a,value:". We can infer an ordering only when we can safely assume that a replica counter will only be incremented by a single replica (based on the ReplicaID)."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"You will find this ID uniqueness requirement in most CRDT implementations. In fact, many CRDTs explicitly mention that it’s up to you to guarantee unique replica IDs, otherwise you might face data corruption (eg. "},{type:b,tag:u,props:{href:"https:\u002F\u002Fdocs.rs\u002Fyrs\u002Flatest\u002Fyrs\u002F#quick-start",rel:[am,an,ao],target:ap},children:[{type:a,value:aY}]},{type:a,value:")."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"This requirement is made more complex by the fact that CRDTs are typically used in distributed P2P scenarios. In those cases, we can’t rely on a central authority to assign IDs that are guaranteed to be globally unique. The most popular solution in those cases is to generate a random replica ID large enough to be statistically unlikely to conflict with another replica ID. The downside of large replica IDs is that they can take up quite a bit of storage within our CRDT, depending on the implementation. So in these cases, we need to balance our accepted risk of data corruption with our efficiency requirements or introduce a global “coordination” entity to assign unique IDs."}]},{type:a,value:f},{type:b,tag:as,props:{id:bn},children:[{type:b,tag:u,props:{href:"#remarks-on-version-vectors-storage",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:bo}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Version Vectors are a powerful tool in our distributed systems toolbox. Their main downside is that they can take quite a bit of storage in our data structure, and in certain scenarios, a "},{type:b,tag:M,props:{},children:[{type:a,value:"lot"}]},{type:a,value:" of storage."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The ideal scenario for Version Vectors is when any given data entry is only ever modified by a single replica:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"As you can see, because our data is only modified by Alice, our Version Vector’s size doesn’t grow."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"If at some point another replica decides to modify the data, our Version Vector’s size grows by one:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Therefore, the worst-case scenario happens when a data entry is modified by a different replica every time:"}]},{type:a,value:f},{type:b,tag:E,props:{className:[F]},children:[{type:b,tag:G,props:{className:[H,I]},children:[{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:b$}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:R}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:l}]},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:b$}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:w}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,m,n]},children:[{type:a,value:"david"}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"That adds up quickly!"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"The problem is that we can fall into this worst-case scenario quite easily if we are not careful. For example, given that replica IDs have to be unique, we could decide to solve the problem by generating a random ID every time our CRDT is initialized. At this point, every time we modify the same entry, the Version Vector size will grow by one. Given that our CRDT is likely to be initialized at least once every time the user starts our application, modifying the same entries will cause the Version Vector size to grow fast!"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"For some use cases, this might not be a significant problem, for example in scenarios in which the creation of new objects is more common than edits or when Replica IDs can be reused among different sessions. There is also a more efficient version of Version Vectors called "},{type:b,tag:M,props:{},children:[{type:a,value:"Dotted Version Vectors"}]},{type:a,value:", which in some cases can bring significant space savings. We’ll hopefully cover it in a future chapter of the series, so stay tuned :)"}]},{type:a,value:f},{type:b,tag:bs,props:{id:"conclusions"},children:[{type:b,tag:u,props:{href:"#conclusions",ariaHidden:aa,tabIndex:ac},children:[{type:b,tag:c,props:{className:[ad,ae]},children:[]}]},{type:a,value:"Conclusions"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"That was quite a ride! We finally have a working CRDT Set implementation, but there is still a lot to discuss:"}]},{type:a,value:f},{type:b,tag:ba,props:{},children:[{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"Our CRDT Set only keeps growing over time, even after we remove elements. Can we implement deletes more efficiently?"}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"When we synchronize the replicas of our CRDT, we currently need to send the entire state to each other, which could become prohibitive expensive after a certain size. Can we implement a more efficient synchronization in which only the “new” data is sent over the wire?"}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:a,value:"What about other data structures like Lists and Maps?"}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"These will be the topics of the next chapters, so stay tuned!"}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"PS: All the code is available in this repository: "},{type:b,tag:u,props:{href:ca,rel:[am,an,ao],target:ap},children:[{type:a,value:ca}]}]}]},excerpt:{type:aO,children:[{type:b,tag:j,props:{},children:[{type:a,value:bp},{type:b,tag:aC,props:{to:aP},children:[{type:a,value:bq}]},{type:a,value:br}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002F2024-02-25-understanding-crdts-improving-our-set-chapter-2",extension:cb,createdAt:aM,updatedAt:aM},header:{slug:bc,name:aN,toc:[],body:{type:aO,children:[{type:b,tag:aw,props:{},children:[{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Welcome to "},{type:b,tag:M,props:{},children:[{type:a,value:aN}]},{type:a,value:", a series of articles in which we’ll discuss CRDTs from the ground up. We’ll start from the basic concepts, trying to discuss different algorithms and data structures using simple JavaScript implementations, and we’ll gradually work towards a high-performance, JSON CRDT implementation written in Rust."}]},{type:a,value:f},{type:b,tag:j,props:{},children:[{type:a,value:"Chapters (so far):"}]},{type:a,value:f},{type:b,tag:aQ,props:{},children:[{type:a,value:f},{type:b,tag:S,props:{},children:[{type:b,tag:aC,props:{to:aP},children:[{type:a,value:"A Gentle Introduction"}]}]},{type:a,value:f},{type:b,tag:S,props:{},children:[{type:b,tag:aC,props:{to:"\u002Fblog\u002Funderstanding-crdts-improving-our-set-chapter-2"},children:[{type:a,value:"Improving our Set"}]}]},{type:a,value:f}]},{type:a,value:f}]}]},dir:"\u002Fheaders",path:"\u002Fheaders\u002Funderstanding-crdt",extension:cb,createdAt:aM,updatedAt:aM}}],fetch:{},mutations:void 0}}("text","element","span","token","punctuation","\n"," ","operator","code","p","}","{","literal-property","property",":","(","=",")","number",".","a","property-access",",","function","keyword","\n  ",";","method","alice","1","div","nuxt-content-highlight","pre","language-javascript","line-numbers","comment","b","string","em","console","removals","\nremovals ","constant","VV","li","class-name","\"a\"","elements ","control-flow","\n      ","2","\n    ","bob","has","true","elements",-1,"icon","icon-link","const","add","log","replicaA","this","\n\n","merge","nofollow","noopener","noreferrer","_blank",2,"new","h2","\"2024-02-24\"","remove","after","blockquote","  ","\n\n  ","strong","{alice: 2}","3","nuxt-link","CRDTSet","replicaB","\u002F\u002F false"," b","parameter","set","get","if","{alice: 1}","2024-02-26T09:00:09.120Z","Understanding CRDTs","root","\u002Fblog\u002Funderstanding-crdts-a-gentle-introduction-chapter-1","ol","\"2024-02-23\"","===","nil","undefined","return","\n\n    "," additionTime","here","await","waitFor","10","ul","{alice: 1, bob: 1}","understanding-crdt","attempt-0-removing-elements","Attempt 0: Removing elements","attempt-1-adding-timestamps","Attempt 1: Adding timestamps","physical-time-and-distributed-systems","Physical time and distributed systems","attempt-2-version-vectors","Attempt 2: Version Vectors","remarks-on-replica-ids","Remarks on Replica IDs","remarks-on-version-vectors-storage","Remarks on Version Vectors storage","In the ","previous article",", we implemented a basic Set with support for additions and removals, as well as basic CRDT semantics. Despite working in simple cases, we also highlighted two significant limitations:","h1"," replicaA ","\nreplicaA","\u002F\u002F true"," replicaB ","\nreplicaB"," was added "," removing element ","ordering"," and ","\nelements ","Date","getTime","boolean"," removalTime ","for","let","[","]","of"," otherSet","\n        existingAdditionTime ","||","\u003C","\n        "," removalTime","\n        existingRemovalTime ","\n  replicaB","\n\n  replicaA","img",""," map:","\"2099-02-24\"","unique"," comes ","carl","https:\u002F\u002Fgithub.com\u002Ffederico-terzi\u002Fcrdt-experiments",".md")));